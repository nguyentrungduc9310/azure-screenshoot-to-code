"""
Advanced Vulnerability Scanner
Comprehensive security scanning system for automated vulnerability detection and assessment
"""
import asyncio
import json
import re
import subprocess
import tempfile
import hashlib
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import os
import zipfile
import tarfile
from pathlib import Path

try:
    from shared.monitoring.structured_logger import StructuredLogger
except ImportError:
    # Import mock logger directly to avoid circular imports
    import importlib.util
    import os
    
    # Get the path relative to this file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    mock_logger_path = os.path.join(current_dir, '..', 'cicd', 'mock_logger.py')
    
    spec = importlib.util.spec_from_file_location("mock_logger", mock_logger_path)
    mock_logger_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mock_logger_module)
    StructuredLogger = mock_logger_module.MockStructuredLogger


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class ScanType(str, Enum):
    """Security scan types"""
    SAST = "static_analysis"  # Static Application Security Testing
    DAST = "dynamic_analysis"  # Dynamic Application Security Testing
    SCA = "software_composition"  # Software Composition Analysis
    SECRETS = "secrets_detection"
    CONTAINER = "container_security"
    INFRASTRUCTURE = "infrastructure_security"
    COMPLIANCE = "compliance_check"


class VulnerabilityStatus(str, Enum):
    """Vulnerability status"""
    OPEN = "open"
    FIXED = "fixed"
    ACCEPTED = "accepted"
    FALSE_POSITIVE = "false_positive"
    SUPPRESSED = "suppressed"


@dataclass
class SecurityVulnerability:
    """Security vulnerability finding"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    scan_type: ScanType
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cwe_id: Optional[str] = None
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN
    first_seen: Optional[datetime] = None
    last_seen: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ScanResult:
    """Security scan result"""
    scan_id: str
    scan_type: ScanType
    target: str
    start_time: datetime
    end_time: Optional[datetime]
    status: str
    vulnerabilities: List[SecurityVulnerability]
    summary: Dict[str, int]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def duration_seconds(self) -> float:
        """Get scan duration in seconds"""
        if self.end_time and self.start_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0
    
    @property
    def critical_count(self) -> int:
        """Count of critical vulnerabilities"""
        return len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
    
    @property
    def high_count(self) -> int:
        """Count of high severity vulnerabilities"""
        return len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])


@dataclass
class ScanConfiguration:
    """Security scan configuration"""
    enabled_scan_types: Set[ScanType] = field(default_factory=lambda: set(ScanType))
    max_scan_duration_minutes: int = 60
    parallel_scans: bool = True
    fail_on_critical: bool = True
    fail_on_high: bool = False
    exclude_patterns: List[str] = field(default_factory=list)
    include_patterns: List[str] = field(default_factory=lambda: ["**/*.py", "**/*.js", "**/*.ts"])
    custom_rules: Dict[str, Any] = field(default_factory=dict)
    compliance_frameworks: List[str] = field(default_factory=lambda: ["OWASP", "CIS", "NIST"])


class AdvancedVulnerabilityScanner:
    """Advanced vulnerability scanner with multiple scan engines"""
    
    def __init__(self, logger: StructuredLogger, config: ScanConfiguration = None):
        self.logger = logger
        self.config = config or ScanConfiguration()
        
        # Scan engines
        self.scan_engines = {
            ScanType.SAST: self._sast_scan,
            ScanType.SECRETS: self._secrets_scan,
            ScanType.SCA: self._sca_scan,
            ScanType.CONTAINER: self._container_scan,
            ScanType.INFRASTRUCTURE: self._infrastructure_scan,
            ScanType.COMPLIANCE: self._compliance_scan
        }
        
        # Known vulnerability patterns
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        
        # Scan history
        self.scan_history: Dict[str, ScanResult] = {}
        
        self.logger.info("Advanced vulnerability scanner initialized",
                        enabled_scans=list(self.config.enabled_scan_types))
    
    async def scan_application(self, target_path: str, scan_types: Optional[Set[ScanType]] = None) -> Dict[ScanType, ScanResult]:
        """Perform comprehensive application security scan"""
        
        if scan_types is None:
            scan_types = self.config.enabled_scan_types
        
        self.logger.info("Starting comprehensive security scan",
                        target=target_path,
                        scan_types=[st.value for st in scan_types])
        
        results = {}
        
        if self.config.parallel_scans:
            # Run scans in parallel
            tasks = []
            for scan_type in scan_types:
                if scan_type in self.scan_engines:
                    task = asyncio.create_task(
                        self._execute_scan(scan_type, target_path)
                    )
                    tasks.append((scan_type, task))
            
            # Wait for all scans to complete
            for scan_type, task in tasks:
                try:
                    result = await asyncio.wait_for(
                        task, 
                        timeout=self.config.max_scan_duration_minutes * 60
                    )
                    results[scan_type] = result
                except asyncio.TimeoutError:
                    self.logger.error("Scan timeout", scan_type=scan_type.value)
                    results[scan_type] = self._create_timeout_result(scan_type, target_path)
                except Exception as e:
                    self.logger.error("Scan failed", scan_type=scan_type.value, error=str(e))
                    results[scan_type] = self._create_error_result(scan_type, target_path, str(e))
        else:
            # Run scans sequentially
            for scan_type in scan_types:
                if scan_type in self.scan_engines:
                    try:
                        result = await asyncio.wait_for(
                            self._execute_scan(scan_type, target_path),
                            timeout=self.config.max_scan_duration_minutes * 60
                        )
                        results[scan_type] = result
                    except Exception as e:
                        self.logger.error("Scan failed", scan_type=scan_type.value, error=str(e))
                        results[scan_type] = self._create_error_result(scan_type, target_path, str(e))
        
        # Store scan results
        for scan_type, result in results.items():
            self.scan_history[result.scan_id] = result
        
        self.logger.info("Security scan completed",
                        target=target_path,
                        total_scans=len(results),
                        total_vulnerabilities=sum(len(r.vulnerabilities) for r in results.values()))
        
        return results
    
    async def _execute_scan(self, scan_type: ScanType, target_path: str) -> ScanResult:
        """Execute a specific scan type"""
        scan_id = self._generate_scan_id(scan_type, target_path)
        start_time = datetime.utcnow()
        
        self.logger.info("Starting scan", scan_type=scan_type.value, scan_id=scan_id)
        
        try:
            # Execute the scan
            vulnerabilities = await self.scan_engines[scan_type](target_path)
            
            # Create scan result
            result = ScanResult(
                scan_id=scan_id,
                scan_type=scan_type,
                target=target_path,
                start_time=start_time,
                end_time=datetime.utcnow(),
                status="completed",
                vulnerabilities=vulnerabilities,
                summary=self._create_summary(vulnerabilities)
            )
            
            self.logger.info("Scan completed",
                           scan_type=scan_type.value,
                           scan_id=scan_id,
                           vulnerabilities_found=len(vulnerabilities),
                           duration_seconds=result.duration_seconds)
            
            return result
            
        except Exception as e:
            self.logger.error("Scan execution failed",
                            scan_type=scan_type.value,
                            scan_id=scan_id,
                            error=str(e))
            raise
    
    async def _sast_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Static Application Security Testing"""
        vulnerabilities = []
        
        # Scan Python files for common security issues
        python_files = list(Path(target_path).rglob("*.py"))
        
        for file_path in python_files:
            if self._should_exclude_file(str(file_path)):
                continue
            
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for common security issues
                file_vulnerabilities = await self._analyze_python_code(file_path, content)
                vulnerabilities.extend(file_vulnerabilities)
                
            except Exception as e:
                self.logger.warning("Failed to scan file",
                                  file=str(file_path),
                                  error=str(e))
        
        return vulnerabilities
    
    async def _analyze_python_code(self, file_path: Path, content: str) -> List[SecurityVulnerability]:
        """Analyze Python code for security vulnerabilities"""
        vulnerabilities = []
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            # Check for various security patterns
            for pattern_name, pattern_config in self.vulnerability_patterns.items():
                if re.search(pattern_config["pattern"], line, re.IGNORECASE):
                    vulnerability = SecurityVulnerability(
                        id=self._generate_vulnerability_id(file_path, line_num, pattern_name),
                        title=pattern_config["title"],
                        description=pattern_config["description"],
                        severity=VulnerabilitySeverity(pattern_config["severity"]),
                        scan_type=ScanType.SAST,
                        file_path=str(file_path),
                        line_number=line_num,
                        cwe_id=pattern_config.get("cwe_id"),
                        remediation=pattern_config.get("remediation"),
                        first_seen=datetime.utcnow(),
                        last_seen=datetime.utcnow(),
                        metadata={"matched_line": line.strip()}
                    )
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _secrets_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Scan for exposed secrets and credentials"""
        vulnerabilities = []
        
        # Common secret patterns
        secret_patterns = {
            "aws_access_key": {
                "pattern": r"AKIA[0-9A-Z]{16}",
                "title": "AWS Access Key Exposed",
                "severity": "critical"
            },
            "generic_api_key": {
                "pattern": r"['\"]?[a-zA-Z0-9_-]*api[_-]?key['\"]?\s*[:=]\s*['\"]?[a-zA-Z0-9_-]{20,}['\"]?",
                "title": "Generic API Key Exposed",
                "severity": "high"
            },
            "jwt_token": {
                "pattern": r"eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*",
                "title": "JWT Token Exposed",
                "severity": "medium"
            },
            "password_field": {
                "pattern": r"password\s*[:=]\s*['\"][^'\"]{8,}['\"]",
                "title": "Hardcoded Password",
                "severity": "high"
            }
        }
        
        # Scan all files
        for file_path in Path(target_path).rglob("*"):
            if not file_path.is_file() or self._should_exclude_file(str(file_path)):
                continue
            
            try:
                # Only scan text files
                if self._is_text_file(file_path):
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    lines = content.split('\n')
                    for line_num, line in enumerate(lines, 1):
                        for secret_type, pattern_config in secret_patterns.items():
                            if re.search(pattern_config["pattern"], line, re.IGNORECASE):
                                vulnerability = SecurityVulnerability(
                                    id=self._generate_vulnerability_id(file_path, line_num, secret_type),
                                    title=pattern_config["title"],
                                    description=f"Potential secret detected: {secret_type}",
                                    severity=VulnerabilitySeverity(pattern_config["severity"]),
                                    scan_type=ScanType.SECRETS,
                                    file_path=str(file_path),
                                    line_number=line_num,
                                    remediation="Remove hardcoded secrets and use environment variables or secure vaults",
                                    first_seen=datetime.utcnow(),
                                    last_seen=datetime.utcnow(),
                                    metadata={"secret_type": secret_type}
                                )
                                vulnerabilities.append(vulnerability)
            
            except Exception as e:
                self.logger.debug("Failed to scan file for secrets",
                                file=str(file_path),
                                error=str(e))
        
        return vulnerabilities
    
    async def _sca_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Software Composition Analysis - scan dependencies for vulnerabilities"""
        vulnerabilities = []
        
        # Check Python requirements
        requirements_files = list(Path(target_path).rglob("requirements*.txt"))
        requirements_files.extend(Path(target_path).rglob("Pipfile"))
        requirements_files.extend(Path(target_path).rglob("pyproject.toml"))
        
        for req_file in requirements_files:
            try:
                # Parse dependencies
                dependencies = await self._parse_dependencies(req_file)
                
                # Check each dependency for known vulnerabilities
                for dep_name, dep_version in dependencies.items():
                    dep_vulnerabilities = await self._check_dependency_vulnerabilities(
                        dep_name, dep_version, str(req_file)
                    )
                    vulnerabilities.extend(dep_vulnerabilities)
            
            except Exception as e:
                self.logger.warning("Failed to scan dependencies",
                                  file=str(req_file),
                                  error=str(e))
        
        return vulnerabilities
    
    async def _container_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Container security scan"""
        vulnerabilities = []
        
        # Find Dockerfiles
        dockerfiles = list(Path(target_path).rglob("Dockerfile*"))
        
        for dockerfile in dockerfiles:
            try:
                with open(dockerfile, 'r') as f:
                    content = f.read()
                
                # Check for container security issues
                container_vulnerabilities = await self._analyze_dockerfile(dockerfile, content)
                vulnerabilities.extend(container_vulnerabilities)
            
            except Exception as e:
                self.logger.warning("Failed to scan Dockerfile",
                                  file=str(dockerfile),
                                  error=str(e))
        
        return vulnerabilities
    
    async def _infrastructure_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Infrastructure as Code security scan"""
        vulnerabilities = []
        
        # Find infrastructure files
        iac_files = []
        iac_files.extend(Path(target_path).rglob("*.yml"))
        iac_files.extend(Path(target_path).rglob("*.yaml"))
        iac_files.extend(Path(target_path).rglob("*.tf"))
        iac_files.extend(Path(target_path).rglob("*.json"))
        
        for iac_file in iac_files:
            if self._should_exclude_file(str(iac_file)):
                continue
            
            try:
                # Analyze infrastructure configuration
                iac_vulnerabilities = await self._analyze_infrastructure_file(iac_file)
                vulnerabilities.extend(iac_vulnerabilities)
            
            except Exception as e:
                self.logger.debug("Failed to scan infrastructure file",
                                file=str(iac_file),
                                error=str(e))
        
        return vulnerabilities
    
    async def _compliance_scan(self, target_path: str) -> List[SecurityVulnerability]:
        """Compliance framework checking"""
        vulnerabilities = []
        
        for framework in self.config.compliance_frameworks:
            framework_vulnerabilities = await self._check_compliance_framework(target_path, framework)
            vulnerabilities.extend(framework_vulnerabilities)
        
        return vulnerabilities
    
    async def _parse_dependencies(self, requirements_file: Path) -> Dict[str, str]:
        """Parse dependencies from requirements file"""
        dependencies = {}
        
        try:
            with open(requirements_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Simple parsing for requirements.txt format
                        if '==' in line:
                            name, version = line.split('==', 1)
                            dependencies[name.strip()] = version.strip()
                        elif '>=' in line:
                            name, version = line.split('>=', 1)
                            dependencies[name.strip()] = f">={version.strip()}"
        
        except Exception as e:
            self.logger.warning("Failed to parse dependencies",
                              file=str(requirements_file),
                              error=str(e))
        
        return dependencies
    
    async def _check_dependency_vulnerabilities(self, dep_name: str, dep_version: str, file_path: str) -> List[SecurityVulnerability]:
        """Check dependency for known vulnerabilities"""
        # This would typically integrate with vulnerability databases like OSV, CVE, etc.
        # For now, we'll simulate with some known vulnerable packages
        
        vulnerable_packages = {
            "requests": {
                "versions": ["2.19.0", "2.19.1"],
                "cve": "CVE-2018-18074",
                "severity": "medium",
                "description": "Requests library vulnerable to SSRF"
            },
            "flask": {
                "versions": ["0.12.0", "0.12.1", "0.12.2"],
                "cve": "CVE-2018-1000656",
                "severity": "high",
                "description": "Flask development server vulnerable to denial of service"
            }
        }
        
        vulnerabilities = []
        
        if dep_name in vulnerable_packages:
            vuln_info = vulnerable_packages[dep_name]
            if dep_version in vuln_info["versions"]:
                vulnerability = SecurityVulnerability(
                    id=self._generate_vulnerability_id(Path(file_path), 0, f"dep_{dep_name}"),
                    title=f"Vulnerable Dependency: {dep_name}",
                    description=vuln_info["description"],
                    severity=VulnerabilitySeverity(vuln_info["severity"]),
                    scan_type=ScanType.SCA,
                    file_path=file_path,
                    cve_id=vuln_info["cve"],
                    remediation=f"Update {dep_name} to a non-vulnerable version",
                    first_seen=datetime.utcnow(),
                    last_seen=datetime.utcnow(),
                    metadata={
                        "package": dep_name,
                        "version": dep_version,
                        "vulnerable_versions": vuln_info["versions"]
                    }
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _analyze_dockerfile(self, dockerfile: Path, content: str) -> List[SecurityVulnerability]:
        """Analyze Dockerfile for security issues"""
        vulnerabilities = []
        lines = content.split('\n')
        
        docker_patterns = {
            "root_user": {
                "pattern": r"USER\s+root",
                "title": "Container Running as Root",
                "severity": "medium",
                "description": "Container is configured to run as root user"
            },
            "sudo_installation": {
                "pattern": r"RUN.*apt-get.*install.*sudo",
                "title": "Sudo Installed in Container",
                "severity": "low",
                "description": "Sudo should not be installed in containers"
            },
            "no_user_specified": {
                "pattern": r"^(?!.*USER).*$",
                "title": "No User Specified",
                "severity": "medium",
                "description": "No non-root user specified for container"
            }
        }
        
        for line_num, line in enumerate(lines, 1):
            for pattern_name, pattern_config in docker_patterns.items():
                if pattern_name == "no_user_specified":
                    # Special handling for missing USER directive
                    continue
                
                if re.search(pattern_config["pattern"], line, re.IGNORECASE):
                    vulnerability = SecurityVulnerability(
                        id=self._generate_vulnerability_id(dockerfile, line_num, pattern_name),
                        title=pattern_config["title"],
                        description=pattern_config["description"],
                        severity=VulnerabilitySeverity(pattern_config["severity"]),
                        scan_type=ScanType.CONTAINER,
                        file_path=str(dockerfile),
                        line_number=line_num,
                        remediation="Follow Docker security best practices",
                        first_seen=datetime.utcnow(),
                        last_seen=datetime.utcnow()
                    )
                    vulnerabilities.append(vulnerability)
        
        # Check if USER directive is missing
        if not any("USER" in line for line in lines):
            vulnerability = SecurityVulnerability(
                id=self._generate_vulnerability_id(dockerfile, 0, "no_user_specified"),
                title="No User Specified",
                description="Container does not specify a non-root user",
                severity=VulnerabilitySeverity.MEDIUM,
                scan_type=ScanType.CONTAINER,
                file_path=str(dockerfile),
                remediation="Add USER directive to run container as non-root user",
                first_seen=datetime.utcnow(),
                last_seen=datetime.utcnow()
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _analyze_infrastructure_file(self, file_path: Path) -> List[SecurityVulnerability]:
        """Analyze infrastructure configuration files"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Check for common misconfigurations
            if file_path.suffix.lower() in ['.yml', '.yaml']:
                # Kubernetes/Docker Compose security checks
                if 'privileged: true' in content:
                    vulnerability = SecurityVulnerability(
                        id=self._generate_vulnerability_id(file_path, 0, "privileged_container"),
                        title="Privileged Container",
                        description="Container configured with privileged access",
                        severity=VulnerabilitySeverity.HIGH,
                        scan_type=ScanType.INFRASTRUCTURE,
                        file_path=str(file_path),
                        remediation="Remove privileged access unless absolutely necessary",
                        first_seen=datetime.utcnow(),
                        last_seen=datetime.utcnow()
                    )
                    vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.debug("Failed to analyze infrastructure file",
                            file=str(file_path),
                            error=str(e))
        
        return vulnerabilities
    
    async def _check_compliance_framework(self, target_path: str, framework: str) -> List[SecurityVulnerability]:
        """Check compliance with security framework"""
        vulnerabilities = []
        
        if framework == "OWASP":
            # OWASP Top 10 compliance checks
            owasp_checks = await self._owasp_compliance_check(target_path)
            vulnerabilities.extend(owasp_checks)
        
        elif framework == "CIS":
            # CIS benchmarks
            cis_checks = await self._cis_compliance_check(target_path)
            vulnerabilities.extend(cis_checks)
        
        elif framework == "NIST":
            # NIST cybersecurity framework
            nist_checks = await self._nist_compliance_check(target_path)
            vulnerabilities.extend(nist_checks)
        
        return vulnerabilities
    
    async def _owasp_compliance_check(self, target_path: str) -> List[SecurityVulnerability]:
        """OWASP Top 10 compliance checking"""
        vulnerabilities = []
        
        # Check for OWASP issues in configuration files
        config_files = list(Path(target_path).rglob("*.py"))
        config_files.extend(Path(target_path).rglob("*.yml"))
        config_files.extend(Path(target_path).rglob("*.yaml"))
        
        for config_file in config_files:
            if self._should_exclude_file(str(config_file)):
                continue
            
            try:
                with open(config_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # A01: Broken Access Control
                if 'debug.*=.*true' in content.lower():
                    vulnerability = SecurityVulnerability(
                        id=self._generate_vulnerability_id(config_file, 0, "debug_enabled"),
                        title="Debug Mode Enabled",
                        description="Debug mode should not be enabled in production",
                        severity=VulnerabilitySeverity.MEDIUM,
                        scan_type=ScanType.COMPLIANCE,
                        file_path=str(config_file),
                        remediation="Disable debug mode in production environments",
                        first_seen=datetime.utcnow(),
                        last_seen=datetime.utcnow(),
                        metadata={"owasp_category": "A01", "framework": "OWASP"}
                    )
                    vulnerabilities.append(vulnerability)
            
            except Exception as e:
                self.logger.debug("Failed OWASP compliance check",
                                file=str(config_file),
                                error=str(e))
        
        return vulnerabilities
    
    async def _cis_compliance_check(self, target_path: str) -> List[SecurityVulnerability]:
        """CIS benchmark compliance checking"""
        # Placeholder for CIS compliance checks
        return []
    
    async def _nist_compliance_check(self, target_path: str) -> List[SecurityVulnerability]:
        """NIST cybersecurity framework compliance checking"""
        # Placeholder for NIST compliance checks
        return []
    
    def generate_scan_report(self, scan_results: Dict[ScanType, ScanResult]) -> Dict[str, Any]:
        """Generate comprehensive scan report"""
        
        all_vulnerabilities = []
        for result in scan_results.values():
            all_vulnerabilities.extend(result.vulnerabilities)
        
        # Summary statistics
        summary = {
            "total_vulnerabilities": len(all_vulnerabilities),
            "critical": len([v for v in all_vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high": len([v for v in all_vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]),
            "medium": len([v for v in all_vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM]),
            "low": len([v for v in all_vulnerabilities if v.severity == VulnerabilitySeverity.LOW]),
            "info": len([v for v in all_vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        }
        
        # Risk assessment
        risk_score = self._calculate_risk_score(all_vulnerabilities)
        
        # Remediation priorities
        remediation_priorities = self._generate_remediation_priorities(all_vulnerabilities)
        
        # Compliance status
        compliance_status = self._assess_compliance_status(all_vulnerabilities)
        
        return {
            "scan_metadata": {
                "scan_date": datetime.utcnow().isoformat(),
                "scan_types": [st.value for st in scan_results.keys()],
                "total_scan_duration": sum(r.duration_seconds for r in scan_results.values()),
                "scan_status": "completed"
            },
            "summary": summary,
            "risk_assessment": {
                "overall_risk_score": risk_score,
                "risk_level": self._get_risk_level(risk_score),
                "pass_fail_status": "FAIL" if summary["critical"] > 0 or (self.config.fail_on_high and summary["high"] > 0) else "PASS"
            },
            "vulnerabilities": [
                {
                    "id": v.id,
                    "title": v.title,
                    "severity": v.severity.value,
                    "scan_type": v.scan_type.value,
                    "file_path": v.file_path,
                    "line_number": v.line_number,
                    "description": v.description,
                    "remediation": v.remediation,
                    "cwe_id": v.cwe_id,
                    "cve_id": v.cve_id,
                    "status": v.status.value
                }
                for v in all_vulnerabilities
            ],
            "remediation_priorities": remediation_priorities,
            "compliance_status": compliance_status,
            "scan_details": {
                scan_type.value: {
                    "scan_id": result.scan_id,
                    "duration_seconds": result.duration_seconds,
                    "vulnerabilities_found": len(result.vulnerabilities),
                    "status": result.status
                }
                for scan_type, result in scan_results.items()
            }
        }
    
    def _load_vulnerability_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Load vulnerability detection patterns"""
        return {
            "sql_injection": {
                "pattern": r"(execute|query|cursor\.execute).*%.*",
                "title": "Potential SQL Injection",
                "description": "SQL query construction using string formatting may be vulnerable to injection",
                "severity": "high",
                "cwe_id": "CWE-89",
                "remediation": "Use parameterized queries or ORM methods"
            },
            "command_injection": {
                "pattern": r"(os\.system|subprocess\.call|subprocess\.run|subprocess\.Popen).*shell=True",
                "title": "Command Injection Risk",
                "description": "Shell command execution with user input may be vulnerable to injection",
                "severity": "high",
                "cwe_id": "CWE-78",
                "remediation": "Avoid shell=True or sanitize input"
            },
            "hardcoded_secret": {
                "pattern": r"(password|secret|key|token)\s*=\s*['\"][^'\"]+['\"]",
                "title": "Hardcoded Secret",
                "description": "Hardcoded credentials found in source code",
                "severity": "critical",
                "cwe_id": "CWE-798",
                "remediation": "Use environment variables or secure configuration"
            },
            "debug_mode": {
                "pattern": r"debug\s*=\s*True",
                "title": "Debug Mode Enabled",
                "description": "Debug mode should not be enabled in production",
                "severity": "medium",
                "cwe_id": "CWE-489",
                "remediation": "Disable debug mode in production"
            },
            "weak_crypto": {
                "pattern": r"(md5|sha1)\(",
                "title": "Weak Cryptographic Hash",
                "description": "Weak cryptographic hash function in use",
                "severity": "medium",
                "cwe_id": "CWE-327",
                "remediation": "Use SHA-256 or stronger hash functions"
            }
        }
    
    def _should_exclude_file(self, file_path: str) -> bool:
        """Check if file should be excluded from scanning"""
        for pattern in self.config.exclude_patterns:
            if re.match(pattern, file_path):
                return True
        return False
    
    def _is_text_file(self, file_path: Path) -> bool:
        """Check if file is a text file"""
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(1024)
                return b'\x00' not in chunk
        except:
            return False
    
    def _generate_scan_id(self, scan_type: ScanType, target: str) -> str:
        """Generate unique scan ID"""
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        target_hash = hashlib.md5(target.encode()).hexdigest()[:8]
        return f"{scan_type.value}_{timestamp}_{target_hash}"
    
    def _generate_vulnerability_id(self, file_path: Path, line_number: int, pattern_name: str) -> str:
        """Generate unique vulnerability ID"""
        file_hash = hashlib.md5(str(file_path).encode()).hexdigest()[:8]
        return f"{pattern_name}_{file_hash}_{line_number}"
    
    def _create_summary(self, vulnerabilities: List[SecurityVulnerability]) -> Dict[str, int]:
        """Create vulnerability summary"""
        return {
            "total": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]),
            "medium": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM]),
            "low": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.LOW]),
            "info": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        }
    
    def _create_timeout_result(self, scan_type: ScanType, target: str) -> ScanResult:
        """Create result for timed out scan"""
        return ScanResult(
            scan_id=self._generate_scan_id(scan_type, target),
            scan_type=scan_type,
            target=target,
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            status="timeout",
            vulnerabilities=[],
            summary={"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        )
    
    def _create_error_result(self, scan_type: ScanType, target: str, error: str) -> ScanResult:
        """Create result for failed scan"""
        return ScanResult(
            scan_id=self._generate_scan_id(scan_type, target),
            scan_type=scan_type,
            target=target,
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            status="error",
            vulnerabilities=[],
            summary={"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
            metadata={"error": error}
        )
    
    def _calculate_risk_score(self, vulnerabilities: List[SecurityVulnerability]) -> float:
        """Calculate overall risk score"""
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.MEDIUM: 4.0,
            VulnerabilitySeverity.LOW: 1.0,
            VulnerabilitySeverity.INFO: 0.1
        }
        
        total_score = sum(severity_weights.get(v.severity, 0) for v in vulnerabilities)
        return min(total_score, 100.0)  # Cap at 100
    
    def _get_risk_level(self, risk_score: float) -> str:
        """Get risk level based on score"""
        if risk_score >= 80:
            return "CRITICAL"
        elif risk_score >= 60:
            return "HIGH"
        elif risk_score >= 30:
            return "MEDIUM"
        elif risk_score > 0:
            return "LOW"
        else:
            return "MINIMAL"
    
    def _generate_remediation_priorities(self, vulnerabilities: List[SecurityVulnerability]) -> List[Dict[str, Any]]:
        """Generate prioritized remediation recommendations"""
        # Group vulnerabilities by type and severity
        vulnerability_groups = {}
        
        for vuln in vulnerabilities:
            key = (vuln.title, vuln.severity)
            if key not in vulnerability_groups:
                vulnerability_groups[key] = []
            vulnerability_groups[key].append(vuln)
        
        # Sort by severity and count
        priorities = []
        for (title, severity), vulns in vulnerability_groups.items():
            priority_score = len(vulns) * (10 if severity == VulnerabilitySeverity.CRITICAL else
                                         7 if severity == VulnerabilitySeverity.HIGH else
                                         4 if severity == VulnerabilitySeverity.MEDIUM else
                                         1 if severity == VulnerabilitySeverity.LOW else 0.1)
            
            priorities.append({
                "title": title,
                "severity": severity.value,
                "count": len(vulns),
                "priority_score": priority_score,
                "remediation": vulns[0].remediation if vulns[0].remediation else "Review and fix identified issues"
            })
        
        return sorted(priorities, key=lambda x: x["priority_score"], reverse=True)
    
    def _assess_compliance_status(self, vulnerabilities: List[SecurityVulnerability]) -> Dict[str, Any]:
        """Assess compliance status based on vulnerabilities"""
        compliance_vulnerabilities = [v for v in vulnerabilities if v.scan_type == ScanType.COMPLIANCE]
        
        framework_status = {}
        for framework in self.config.compliance_frameworks:
            framework_vulns = [v for v in compliance_vulnerabilities 
                             if v.metadata.get("framework") == framework]
            
            framework_status[framework] = {
                "total_issues": len(framework_vulns),
                "critical_issues": len([v for v in framework_vulns if v.severity == VulnerabilitySeverity.CRITICAL]),
                "status": "NON_COMPLIANT" if framework_vulns else "COMPLIANT"
            }
        
        return {
            "frameworks": framework_status,
            "overall_compliance": "COMPLIANT" if not compliance_vulnerabilities else "NON_COMPLIANT"
        }